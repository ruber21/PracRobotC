#pragma config(Sensor, S1,     sonarSensor,    sensorSONAR)
#pragma config(Sensor, S2,     compassSensor,  sensorVirtualCompass)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          leftMotor,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#include "hitechnic-compass.h"

int Angulo(int svalue){
	int result;
	/*if(svalue < 0){
	result = ( 128 + svalue ) / 128;
	}
	else{
	result = svalue;
	}*/

	result = (svalue / 10) % 360;
	if (result < 0) result = (-1) * result;
	//result = 360 - result;
	return result;

}

int theta(float valorX, float valorY)
{
	float tangente;
	float result;
	int angle;
	tangente = valorY / valorX;
	result = atan(tangente) * 180 / PI;
	angle = floor(result) + 3;
	return angle;
}

void girar(int g){
	motor[rightMotor] = 7 * g;
	motor[leftMotor] = -7 * g;
}

int x,y;

void imprimirLCD()
{
	x = 0;
	y = 0;
	int b = 0;
	nxtDisplayTextLine(1, "Coordenadas punto");
	nxtDisplayTextLine(2, "Destino");
	nxtDisplayTextLine(4, "X: %d",x);
	nxtDisplayClearTextLine(5);
	nxtDisplayTextLine(5, "Y: %d",y);

	while(b < 2)
	{
		switch(nNxtButtonPressed)
		{
		case kRightButton:
			if(b == 0)
				x++;
			if(b == 1)
				y++;
			wait1Msec(300);
			nxtDisplayClearTextLine(4);
			nxtDisplayTextLine(4, "X: %d", x);
			nxtDisplayClearTextLine(5);
			nxtDisplayTextLine(5, "Y: %d", y);
			break;
		case kLeftButton:
			if(b == 0 && x > 0)
				x--;
			if(b == 1 & y > 0)
				y--;
			wait1Msec(300);
			nxtDisplayClearTextLine(4);
			nxtDisplayTextLine(4, "X: %d", x);
			nxtDisplayClearTextLine(5);
			nxtDisplayTextLine(5, "Y: %d", y);
			break;

		case kEnterButton:
			b++;
			nxtDisplayClearTextLine(4);
			nxtDisplayTextLine(4, "X: %d", x);
			nxtDisplayClearTextLine(5);
			nxtDisplayTextLine(5, "Y: %d", y);
			wait1Msec(300);
			break;
		default: break;
		}
	}
}

task main()
{
	imprimirLCD();
	int alfa;
	int sensor = 0;
	int angulo_final = 0;
	int valor, temp;
	int esc = 20;
	x = x * esc;
	y = y * esc;

	temp = SensorValue[compassSensor];
	//temp = SensorValue[kCompass];
	valor = Angulo(temp);
	alfa = theta(x,y);
	angulo_final = valor - alfa;
	if(angulo_final < 0)
		angulo_final = 360 + angulo_final;
	eraseDisplay();
	nxtDisplayTextLine(4, "Angulo des: %d", alfa);
	nxtDisplayTextLine(5, "Angulo real: %d", valor);
	while(valor != angulo_final)
	{
		temp = SensorValue[compassSensor];
		//temp = SensorValue[kCompass];
		valor = Angulo(temp);
		nxtDisplayTextLine(5, "Angulo real: %d", valor);
		girar(3);
	}

	float xe = 0, ye = 0;
	int B = 0;
	int C = 0;
	int final;
	int obs = 0;
	int ValorUltrasonico = 0;
	temp = 0;
	nMotorEncoder[motorC] = 0;
	nMotorEncoder[motorB] = 0;
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;

	while(true)
	{
		final = sqrt(x*x + y*y);
		eraseDisplay();
		motor[rightMotor] = 26;
		motor[leftMotor] = 26;
		B =(nMotorEncoder[motorB]) / 20;
		C = (nMotorEncoder[motorC]) / 20;
		ValorUltrasonico = SensorValue(sonarSensor);
		nxtDisplayTextLine(2, "Distancia: %d",B);
		nxtDisplayTextLine(4, "Meta: %d", final);
		nxtDisplayTextLine(6, "obastaculo %d", ValorUltrasonico);

		if(ValorUltrasonico < 25)
		{
			obs = 1;
			motor[rightMotor] = 0;
			motor[leftMotor] = 0;
			xe = (cos(alfa * (PI/180)) * (final - B)) + esc/2;
			ye = (sin(alfa) * (PI / 180)) * (final - B) * 1;
			temp = SensorValue[compassSensor];
			//temp = SensorValue[kCompass];
			valor = Angulo(temp);
			angulo_final = valor + alfa;
			if(angulo_final > 359)
				angulo_final = angulo_final - 360;

			while(true)
			{
				temp = SensorValue[compassSensor];
				//temp = SensorValue[kCompass];
				valor = Angulo(temp);
				girar(-3);
				if(valor == angulo_final)
				{
					motor[rightMotor] = 0;
					motor[leftMotor] = 0;
					nMotorEncoder[motorC] = 0;
					nMotorEncoder[motorB] = 0;
					break;
				}
			}

			while(true)
			{
				motor[rightMotor] = 26;
				motor[leftMotor] = 26;

				C = (nMotorEncoder[motorC]) / 20;
				B = (nMotorEncoder[motorB]) / 20;
				eraseDisplay();
				nxtDisplayTextLine(2, "Distancia %d", C);
				nxtDisplayTextLine(6, "Nueva meta %d", xe);

				if(C == floor(xe))
				{
					motor[rightMotor] = 0;
					motor[leftMotor] = 0;
					nMotorEncoder[motorC] = 0;
					nMotorEncoder[motorB] = 0;
					break;
				}
			}

			temp = SensorValue[compassSensor];
			//temp = SensorValue[kCompass];
			valor = Angulo(temp);
			angulo_final = valor  - 90;
			if(angulo_final < 0)
				angulo_final = 360 + angulo_final;
			while(true)
			{
				temp = SensorValue[compassSensor];
				//temp = SensorValue[kCompass];
				valor = Angulo(temp);
				girar(3);
				if(valor == angulo_final)
				{
					motor[rightMotor] = 0;
					motor[leftMotor] = 0;
					nMotorEncoder[motorC] = 0;
					nMotorEncoder[motorB] = 0;
					break;
				}
			}

			while(true)
			{
				motor[rightMotor] = 26;
				motor[leftMotor] = 26;
				C = (nMotorEncoder[motorC]) / 20;
				eraseDisplay();
				nxtDisplayTextLine(2, "Distancia %d", C);
				nxtDisplayTextLine(6, "Nueva meta %d", ye);
				if(C >= floor(ye))
				{
					motor[rightMotor] = 0;
					motor[leftMotor] = 0;
					obs = 0;
					break;
				}
			}

			if(obs == 0 && floor(C) == floor(final))
				break;
		}

	}


}
