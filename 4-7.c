#pragma config(Sensor, S1,     sonarSensor,    sensorSONAR)
#pragma config(Sensor, S2,     kCompass,  sensorI2CHiTechnicCompass)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          leftMotor,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#include "hitechnic-compass.h"

#include "Includes/hitechnic-irseeker-v2.h"

int Angulo(int svalue){
	int result;
	if(svalue < 0)
		result = 128 + svalue + 128;
	else
		result = svalue;

	return result;
}

int theta(float valorX, float valorY)
{
	float tangente;
	float result;
	int angle;

	if(valorX <= 0)
	{
		angle = 90;
	}
	else
	{
		tangente = valorY / valorX;
		result = atan(tangente) * 180 / PI;
		angle = floor(result);
	}


	return angle;
}

void girar(int g){
	motor[rightMotor] = 7 * g;
	motor[leftMotor] = -7 * g;
}

int x,y;

void imprimirLCD()
{
	x = 0;
	y = 0;
	int b = 0;
	nxtDisplayTextLine(1, "Coordenadas punto");
	nxtDisplayTextLine(2, "Destino");
	nxtDisplayTextLine(4, "X: %d",x);
	nxtDisplayClearTextLine(5);
	nxtDisplayTextLine(5, "Y: %d",y);

	while(b < 2)
	{
		switch(nNxtButtonPressed)
		{
		case kRightButton:
			if(b == 0)
				x++;
			if(b == 1)
				y++;
			wait1Msec(300);
			nxtDisplayClearTextLine(4);
			nxtDisplayTextLine(4, "X: %d", x);
			nxtDisplayClearTextLine(5);
			nxtDisplayTextLine(5, "Y: %d", y);
			break;
		case kLeftButton:
			if(b == 0 && x > 0)
				x--;
			if(b == 1 & y > 0)
				y--;
			wait1Msec(300);
			nxtDisplayClearTextLine(4);
			nxtDisplayTextLine(4, "X: %d", x);
			nxtDisplayClearTextLine(5);
			nxtDisplayTextLine(5, "Y: %d", y);
			break;

		case kEnterButton:
			b++;
			nxtDisplayClearTextLine(4);
			nxtDisplayTextLine(4, "X: %d", x);
			nxtDisplayClearTextLine(5);
			nxtDisplayTextLine(5, "Y: %d", y);
			wait1Msec(300);
			break;
		default: break;
		}
	}
}

task main()
{
	imprimirLCD();
	int alfa;
	int sensor = 0;
	int angulo_final = 0;
	int valor;
	int esc = 20;
	x = x * esc;
	y = y * esc;

	sensor = SensorValue[kCompass];
	//temp = SensorValue[kCompass];
	valor = Angulo(sensor);
	alfa = theta(x,y);
	angulo_final = valor - alfa;
	if(angulo_final < 0)
		angulo_final = 360 + angulo_final;
	eraseDisplay();
	nxtDisplayTextLine(3, "Angulo des: %d", alfa);
	nxtDisplayTextLine(5, "Angulo real: %d", valor);
	while(valor != angulo_final)
	{
		sensor = SensorValue[kCompass];
		//temp = SensorValue[kCompass];
		valor = Angulo(sensor);
		nxtDisplayTextLine(5, "Angulo real: %d", valor);
		girar(1);
	}

	float xe = 0, ye = 0;
	int B = 0;
	int C = 0;
	int final;
	int obs = 0;
	int ValorUltrasonico = 0;
	int temp = 0;
	nMotorEncoder[motorC] = 0;
	nMotorEncoder[motorB] = 0;
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;

	while(true)
	{
		final = sqrt(x*x + y*y);
		eraseDisplay();
		motor[rightMotor] = 26;
		motor[leftMotor] = 26;
		B =(nMotorEncoder[motorB]) / 20;
		C = (nMotorEncoder[motorC]) / 20;
		ValorUltrasonico = SensorValue(sonarSensor);
		nxtDisplayTextLine(2, "Distancia: %d",B);
		nxtDisplayTextLine(4, "Meta: %d", final);
		nxtDisplayTextLine(6, "obastaculo %d", ValorUltrasonico);

		if(ValorUltrasonico < 25)
		{
			obs = 1;
			motor[rightMotor] = 0;
			motor[leftMotor] = 0;
			xe = (cos(alfa * (PI/180)) * (final - B)) + esc/2;
			ye = (sin(alfa) * (PI / 180)) * (final - B) * 1;
			sensor = SensorValue[kCompass];
			valor = Angulo(sensor);
			angulo_final = valor + alfa;
			if(angulo_final > 359)
				angulo_final = angulo_final - 360;

			while(true)
			{
				temp = SensorValue[kCompass];
				valor = Angulo(temp);
				girar(-1);
				if(valor == angulo_final)
				{
					motor[rightMotor] = 0;
					motor[leftMotor] = 0;
					nMotorEncoder[motorC] = 0;
					nMotorEncoder[motorB] = 0;
					break;
				}
			}

			while(true)
			{
				motor[rightMotor] = 26;
				motor[leftMotor] = 26;

				C = (nMotorEncoder[motorC]) / 20;
				B = (nMotorEncoder[motorB]) / 20;
				eraseDisplay();
				nxtDisplayTextLine(2, "Distancia %d", C);
				nxtDisplayTextLine(6, "Nueva meta %d", xe);

				if(C == floor(xe))
				{
					motor[rightMotor] = 0;
					motor[leftMotor] = 0;
					nMotorEncoder[motorC] = 0;
					nMotorEncoder[motorB] = 0;
					break;
				}
			}

			temp = SensorValue[kCompass];
			//temp = SensorValue[kCompass];
			valor = Angulo(temp);
			angulo_final = valor  - 90;
			if(angulo_final < 0)
				angulo_final = 360 + angulo_final;

			while(true)
			{
				temp = SensorValue[kCompass];
				valor = Angulo(temp);
				girar(1);
				if(valor == angulo_final)
				{
					motor[rightMotor] = 0;
					motor[leftMotor] = 0;
					nMotorEncoder[motorC] = 0;
					nMotorEncoder[motorB] = 0;
					break;
				}
			}

			while(true)
			{
				motor[rightMotor] = 26;
				motor[leftMotor] = 26;
				C = (nMotorEncoder[motorC]) / 20;
				eraseDisplay();
				nxtDisplayTextLine(2, "Distancia %d", C);
				nxtDisplayTextLine(6, "Nueva meta %d", ye);
				if(C >= floor(ye))
				{
					motor[rightMotor] = 0;
					motor[leftMotor] = 0;
					obs = 0;
					break;
				}
			}

			if(obs == 0 && floor(C) == floor(final))
				break;
		}

	}


}
