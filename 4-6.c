#pragma config(Sensor, S2,     compassSensor,  sensorVirtualCompass)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          leftMotor,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(Sensor, S2, kCompass, sensorI2CHiTechnicCompass)
//#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, 	PIDControl)
//#pragma config(Motor,  motorC,          leftMotor,     tmotorNXT, PIDControl)
//#pragma config(Sensor, S2,     compassSensor,                sensorVirtualCompass)

//#pragma config(Sensor, S1,     HTMC,                sensorI2CCustom)
//#include "hitechnic-compass.h"

int Angulo(int svalue){
	int result;
	/*if(svalue < 0){
	result = ( 128 + svalue ) / 128;
	}
	else{
	result = svalue;
	}*/

	result = (svalue / 10) % 360;
	if (result < 0) result = (-1) * result;
	//result = 360 - result;
	return result;

}

int theta(float valorX, float valorY)
{
	float tangente;
	float result;
	int angle;
	tangente = valorY / valorX;
	result = atan(tangente) * 180 / PI;
	angle = floor(result);
	return angle;
}

void girar()
{
	motor[leftMotor] = 20;
	motor[rightMotor] = -20;
}

int x,y; //Coordenadas destino

void imprimirLCD()
{
	x = 0;
	y = 0;
	int b = 0;
	nxtDisplayTextLine(1, "Coordenadas punto");
	nxtDisplayTextLine(2, "Destino");
	nxtDisplayTextLine(4, "X: %d",x);
	nxtDisplayClearTextLine(5);
	nxtDisplayTextLine(5, "Y: %d",y);

	while(b < 2)
	{
		switch(nNxtButtonPressed)
		{
		case kRightButton:
			if(b == 0)
				x++;
			if(b == 1)
				y++;
			wait1Msec(300);
			nxtDisplayClearTextLine(4);
			nxtDisplayTextLine(4, "X: %d", x);
			nxtDisplayClearTextLine(5);
			nxtDisplayTextLine(5, "Y: %d", y);
			break;
		case kLeftButton:
			if(b == 0 && x > 0)
				x--;
			if(b == 1 & y > 0)
				y--;
			wait1Msec(300);
			nxtDisplayClearTextLine(4);
			nxtDisplayTextLine(4, "X: %d", x);
			nxtDisplayClearTextLine(5);
			nxtDisplayTextLine(5, "Y: %d", y);
			break;

		case kEnterButton:
			b++;
			nxtDisplayClearTextLine(4);
			nxtDisplayTextLine(4, "X: %d", x);
			nxtDisplayClearTextLine(5);
			nxtDisplayTextLine(5, "Y: %d", y);
			wait1Msec(300);
			break;
		default: break;
		}
	}
}

task main()
{
	imprimirLCD();
	int alfa;
	int sensor = 0;
	int esc = 20;
	int angulo_final = 0;
	int valor, temp;
	const tSensors compassSensor = S2;
	//SensorSubType[kCompass] = subTypeHiTechnicCompass;
	//StartTask(taskCompassDeviceDriver);

	x = x * esc;
	y = y * esc;

	//_target = HTMCsetTarget(HTMC);
	temp = SensorValue[compassSensor];
	//temp = SensorValue[kCompass];
	valor = Angulo(temp);
	alfa = theta(x,y);
	angulo_final = valor - alfa;
	if(angulo_final < 0)
		angulo_final = 360 + angulo_final;
	eraseDisplay();
	nxtDisplayTextLine(4, "Angulo des: %d", alfa);
	nxtDisplayTextLine(5, "Angulo real: %d", valor);
	while(valor != angulo_final)
	{
		temp = SensorValue[compassSensor];
		//temp = SensorValue[kCompass];
		valor = Angulo(temp);
		nxtDisplayTextLine(5, "Angulo real: %d", valor);
		girar();
	}

	/////////////Desplazamiento

	int B = 0;
	int C = 0;
	int final;
	nMotorEncoder[motorC] = 0;
	nMotorEncoder	[motorB] = 0;
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
	while(floor(C) <= floor(final))
	{
		final = sqrt((x * x) + (y * y));
		eraseDisplay();
		motor[rightMotor] = 30;
		motor[leftMotor] = 30;
		B = (nMotorEncoder[motorB]) / 20;
		C = (nMotorEncoder[motorC]) / 20;
		nxtDisplayTextLine(3, "Distancia %d", B);
		nxtDisplayTextLine(6, "Meta %d", final);
	}

}
